        -:    0:Source:randomtestadventurer.c
        -:    0:Graph:randomtestadventurer.gcno
        -:    0:Data:randomtestadventurer.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include <stdio.h>
        -:    2:#include <stdlib.h>
        -:    3:#include <string.h>
        -:    4:#include <time.h>
        -:    5:#include "dominion.h"
        -:    6:#include "dominion_helpers.h"
        -:    7:#include "rngs.h"
        -:    8:
        -:    9:#define RANDOM_TEST "adventurer"
        -:   10:#define ITERATIONS 10000
        -:   11:
function main called 1 returned 100% blocks executed 84%
        1:   12:int main() {
        -:   13:
        1:   14:   printf("\nStarting Random Test 1: %s\n", RANDOM_TEST);
call    0 returned 100%
        -:   15:
        -:   16:   struct gameState G;
        1:   17:   int k[10] = {minion, smithy, gardens, tribute, baron, adventurer, cutpurse, mine, embargo, outpost};
        1:   18:   int i, player = 0, cardEffect_fail = 0, handCount_fail = 0, compareCount_fail = 0, deckCount_fail = 0;
        1:   19:   srand(time(NULL));
call    0 returned 100%
call    1 returned 100%
        -:   20:
    10001:   21:   for(i = 0; i < ITERATIONS; i++) {
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:   22:      struct gameState testG;
        -:   23:
        -:   24:      // randomize pre-game info
    10000:   25:      int rand_players = (rand() % (MAX_PLAYERS - 1) + 2);
call    0 returned 100%
    10000:   26:      int rand_deckCount = (rand() % (MAX_DECK - 2) + 3);
call    0 returned 100%
    10000:   27:      int rand_handCount = (rand() % (MAX_HAND - 4) + 5);
call    0 returned 100%
    10000:   28:      int rand_seed = 1000;
        -:   29:
        -:   30:      // initialize the game
    10000:   31:      initializeGame(rand_players, k, rand_seed, &G);
call    0 returned 100%
        -:   32:
        -:   33:      // randomize game info
    10000:   34:      player = rand() % rand_players;
call    0 returned 100%
    10000:   35:      G.whoseTurn = player;
    10000:   36:      G.deckCount[player] = rand_deckCount;
    10000:   37:      G.handCount[player] = rand_handCount;
        -:   38:
        -:   39:
        -:   40:      // copy game info to testG
    10000:   41:      memcpy(&testG, &G, sizeof(struct gameState));
        -:   42:
        -:   43:      // run cardEffect() w/ testG
    10000:   44:      int result = cardEffect(adventurer, 1, 0, 0, &testG, 0, 0);
call    0 returned 100%
        -:   45:
        -:   46:      // check if cardEffect() failed
    10000:   47:      if(result == -1) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   48:         cardEffect_fail++;
        -:   49:      }
        -:   50:
        -:   51:      // check last two cards if they are treasure cards
        -:   52:      int cardDrawn1, cardDrawn2;
    10000:   53:      cardDrawn1 = testG.hand[player][testG.handCount[player] - 2];
    10000:   54:      cardDrawn2 = testG.hand[player][testG.handCount[player] - 1];
    10000:   55:      if((cardDrawn1 == copper || cardDrawn1 == silver || cardDrawn1 == gold) && (cardDrawn2 == copper || cardDrawn2 == silver || cardDrawn2 == gold)) {
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
        -:   56:         ; // do nothing
        -:   57:      }
        -:   58:      else {
       18:   59:         handCount_fail++;
        -:   60:      }
        -:   61:
        -:   62:      // check to see if +2 cards in testG vs G
    10000:   63:      if(G.handCount[player] + 2 == testG.handCount[player]) {
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -:   64:         ; // do nothing
        -:   65:      }
        -:   66:      else {
       18:   67:         compareCount_fail++;
        -:   68:      }
        -:   69:
        -:   70:      // check to see if testG.deckCount is less than G.rand_deckCount
    10000:   71:      if(testG.deckCount[player] < G.deckCount[player]) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   72:         ; // do nothing
        -:   73:      }
        -:   74:      else {
    #####:   75:         deckCount_fail++;
        -:   76:      }
        -:   77:   }
        -:   78:
        -:   79:   // print results
        1:   80:   if(cardEffect_fail == 0 && handCount_fail == 0 && compareCount_fail == 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 never executed
branch  5 never executed
    #####:   81:      printf("All tests passed!\n");
call    0 never executed
        -:   82:   }
        -:   83:   else {
        1:   84:      printf("Some test(s) have failed!\n");
call    0 returned 100%
        -:   85:   }
        1:   86:   printf("CardEffect() failed %d times out of %d iterations.\n", cardEffect_fail, ITERATIONS);
call    0 returned 100%
        1:   87:   printf("testG.handCount +2 treasure cards failed %d times out of %d iterations.\n", handCount_fail, ITERATIONS);
call    0 returned 100%
        1:   88:   printf("testG.handCount +2 cards vs G.handCount failed %d times out of %d iterations.\n", compareCount_fail, ITERATIONS);
call    0 returned 100%
        1:   89:   printf("testG.deckCount less than G.deckCount failed %d times out of %d iterations.\n", deckCount_fail, ITERATIONS);
call    0 returned 100%
        -:   90:
        1:   91:   return 0;
        -:   92:
        -:   93:}
